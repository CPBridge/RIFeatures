<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIFeatures: RIFeatures::RIFeatExtractor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="small_basis.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RIFeatures
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A C++ library for calculating rotation invariant features from 2D images using OpenCV.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>RIFeatures</b></li><li class="navelem"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html">RIFeatExtractor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_r_i_features_1_1_r_i_feat_extractor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RIFeatures::RIFeatExtractor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the main class that encapsulates the rotation invariant feature extraction process.  
 <a href="class_r_i_features_1_1_r_i_feat_extractor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_r_i_feat_extractor_8hpp_source.html">RIFeatExtractor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af16b938a9a35a24e4115f78231739bfb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfb">calculationMethod_enum</a> : unsigned char { <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfbace69d10f09c2f9463511587bc94c0f2b">cmSpatial</a> = 0, 
<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfba5ac7bf4028b3ff633acbc15b1415edfb">cmFrequency</a>, 
<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfba8393f88bba58fc1d31613f9cffcb328e">cmAuto</a>
 }</td></tr>
<tr class="separator:af16b938a9a35a24e4115f78231739bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2714f17c5759c1d0d4dfde647df6ed24"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24">couplingMethod_enum</a> : unsigned char { <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24a941ba36a5a1424f0de64e1e2f8474d8e">comElementwise</a> = 0, 
<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24aa4f291c1aba930a2ea44cf2b1a89e0cd">comVectorised</a>, 
<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24a1b65c5fa21c706bb0f1865c6c3fddddc">comAuto</a>
 }</td></tr>
<tr class="separator:a2714f17c5759c1d0d4dfde647df6ed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997eda5e295d0281a0adf20b44008cc3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3">featureSet_enum</a> : unsigned char { <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3a90c0d4204fea5bf9339472063e0abf65">fsBasic</a> = 0, 
<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3a325b9896dd17d1b8098ece318a592b17">fsSimpleCouple</a>, 
<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3acebbb945eb19cd07c06e6fd61976a02e">fsExtraCouple</a>
 }</td></tr>
<tr class="separator:a997eda5e295d0281a0adf20b44008cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac511557a4d31dffbeaa0845e12779a4e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4e">basisType_enum</a> : unsigned char { <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4ea946178e16dfeaca2689a02d75c844ef3">btSoftHist</a> = 0, 
<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4ea00eae59978045e7d041b8bf1606983b1">btZernike</a>
 }</td></tr>
<tr class="separator:ac511557a4d31dffbeaa0845e12779a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6bf542a8274d1da1346bcad7878feebf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a6bf542a8274d1da1346bcad7878feebf">RIFeatExtractor</a> ()</td></tr>
<tr class="memdesc:a6bf542a8274d1da1346bcad7878feebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a6bf542a8274d1da1346bcad7878feebf">More...</a><br /></td></tr>
<tr class="separator:a6bf542a8274d1da1346bcad7878feebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab857069a31f922ec45adf94fe80d0952"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ab857069a31f922ec45adf94fe80d0952">RIFeatExtractor</a> (const cv::Size image_size, const float basis_diameter, const int num_radii, const int num_rot_orders, const int num_fourier_coefs, const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfb">calculationMethod_enum</a> method=<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfba8393f88bba58fc1d31613f9cffcb328e">cmAuto</a>, const bool use_spatial_memoisation=false, const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24">couplingMethod_enum</a> couple_method=<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24a1b65c5fa21c706bb0f1865c6c3fddddc">comAuto</a>, const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3">featureSet_enum</a> feature_set=<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3a90c0d4204fea5bf9339472063e0abf65">fsBasic</a>, const int max_derived_rotation_order=-1, const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4e">basisType_enum</a> basis_form=<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4ea946178e16dfeaca2689a02d75c844ef3">btSoftHist</a>)</td></tr>
<tr class="memdesc:ab857069a31f922ec45adf94fe80d0952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with initialisation.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#ab857069a31f922ec45adf94fe80d0952">More...</a><br /></td></tr>
<tr class="separator:ab857069a31f922ec45adf94fe80d0952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23bed3ee42d517e33bba3d12db68b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ad23bed3ee42d517e33bba3d12db68b79">initialise</a> (const cv::Size image_size, const float basis_diameter, const int num_radii, const int num_rot_orders, const int num_fourier_coefs, const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfb">calculationMethod_enum</a> method=<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfba8393f88bba58fc1d31613f9cffcb328e">cmAuto</a>, const bool use_spatial_memoisation=false, const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24">couplingMethod_enum</a> couple_method=<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24a1b65c5fa21c706bb0f1865c6c3fddddc">comAuto</a>, const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3">featureSet_enum</a> feature_set=<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3a90c0d4204fea5bf9339472063e0abf65">fsBasic</a>, const int max_derived_rotation_order=-1, const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4e">basisType_enum</a> basis_form=<a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4ea946178e16dfeaca2689a02d75c844ef3">btSoftHist</a>)</td></tr>
<tr class="memdesc:ad23bed3ee42d517e33bba3d12db68b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises or re-initialises an object.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#ad23bed3ee42d517e33bba3d12db68b79">More...</a><br /></td></tr>
<tr class="separator:ad23bed3ee42d517e33bba3d12db68b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8882738b4bd24f20fc46a0377dbf03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#aae8882738b4bd24f20fc46a0377dbf03">createRawFeats</a> ()</td></tr>
<tr class="memdesc:aae8882738b4bd24f20fc46a0377dbf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate all raw features.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#aae8882738b4bd24f20fc46a0377dbf03">More...</a><br /></td></tr>
<tr class="separator:aae8882738b4bd24f20fc46a0377dbf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9337a05a8d826fff396d2eb88ca8b64d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a9337a05a8d826fff396d2eb88ca8b64d">getNumRawFeats</a> () const</td></tr>
<tr class="memdesc:a9337a05a8d826fff396d2eb88ca8b64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of raw features available in the current feature set.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a9337a05a8d826fff396d2eb88ca8b64d">More...</a><br /></td></tr>
<tr class="separator:a9337a05a8d826fff396d2eb88ca8b64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085f643773aed8db95a84e64b906139b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a085f643773aed8db95a84e64b906139b">getNumDerivedFeats</a> () const</td></tr>
<tr class="memdesc:a085f643773aed8db95a84e64b906139b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of derived features available in the current feature set.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a085f643773aed8db95a84e64b906139b">More...</a><br /></td></tr>
<tr class="separator:a085f643773aed8db95a84e64b906139b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0775c8aac6d11548e481802a8b96617"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af0775c8aac6d11548e481802a8b96617">getMaxSpatBasisHalfsize</a> (const int Jmax=-1) const</td></tr>
<tr class="memdesc:af0775c8aac6d11548e481802a8b96617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 'halfsize' of the largest spatial basis function.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#af0775c8aac6d11548e481802a8b96617">More...</a><br /></td></tr>
<tr class="separator:af0775c8aac6d11548e481802a8b96617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e8a11672f8ff87a6224bfd44fb6d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a33e8a11672f8ff87a6224bfd44fb6d39">getFeatsUsingLowJ</a> (const int Jmax, std::vector&lt; int &gt; &amp;output_feature_list) const</td></tr>
<tr class="memdesc:a33e8a11672f8ff87a6224bfd44fb6d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of the derived features that use only small basis functions.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a33e8a11672f8ff87a6224bfd44fb6d39">More...</a><br /></td></tr>
<tr class="separator:a33e8a11672f8ff87a6224bfd44fb6d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5138b75562d7d33bef2f50a2d4d3b5d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a5138b75562d7d33bef2f50a2d4d3b5d8">getFeatsWithGivenR</a> (const int r, std::vector&lt; int &gt; &amp;raw_feat_ind, const bool include_negatives=false, const int Jmax=-1) const</td></tr>
<tr class="memdesc:a5138b75562d7d33bef2f50a2d4d3b5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of raw feature indices with a given effective rotation order.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a5138b75562d7d33bef2f50a2d4d3b5d8">More...</a><br /></td></tr>
<tr class="separator:a5138b75562d7d33bef2f50a2d4d3b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1bc4d502b65c7bab5dcc7855d9c14e"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator &gt; </td></tr>
<tr class="memitem:a6e1bc4d502b65c7bab5dcc7855d9c14e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a6e1bc4d502b65c7bab5dcc7855d9c14e">getDerivedFeature</a> (TInputIterator first_point, const TInputIterator last_point, const int derived_feat_num, TOutputIterator out)</td></tr>
<tr class="memdesc:a6e1bc4d502b65c7bab5dcc7855d9c14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a single derived feature from a number of image locations.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a6e1bc4d502b65c7bab5dcc7855d9c14e">More...</a><br /></td></tr>
<tr class="separator:a6e1bc4d502b65c7bab5dcc7855d9c14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0160c2ddac865364422c67bc3c6a671b"><td class="memTemplParams" colspan="2">template&lt;typename TOutputIterator &gt; </td></tr>
<tr class="memitem:a0160c2ddac865364422c67bc3c6a671b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a0160c2ddac865364422c67bc3c6a671b">getRawFeatureVector</a> (const cv::Point point, TOutputIterator dest)</td></tr>
<tr class="memdesc:a0160c2ddac865364422c67bc3c6a671b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a full raw feature vector for a single image location.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a0160c2ddac865364422c67bc3c6a671b">More...</a><br /></td></tr>
<tr class="separator:a0160c2ddac865364422c67bc3c6a671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59868a6f9574817edbfc9f9c7a62fdd7"><td class="memTemplParams" colspan="2">template&lt;typename TOutputIterator &gt; </td></tr>
<tr class="memitem:a59868a6f9574817edbfc9f9c7a62fdd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a59868a6f9574817edbfc9f9c7a62fdd7">getDerivedFeatureVector</a> (const cv::Point point, TOutputIterator dest)</td></tr>
<tr class="memdesc:a59868a6f9574817edbfc9f9c7a62fdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a full feature vector for a single image location.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a59868a6f9574817edbfc9f9c7a62fdd7">More...</a><br /></td></tr>
<tr class="separator:a59868a6f9574817edbfc9f9c7a62fdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bedc958816f76f8453f8841c820aaac"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator &gt; </td></tr>
<tr class="memitem:a5bedc958816f76f8453f8841c820aaac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a5bedc958816f76f8453f8841c820aaac">getRawFeatureArg</a> (TInputIterator first_point, const TInputIterator last_point, const int raw_feature_index, TOutputIterator cos_dest, TOutputIterator sin_dest, const bool flip_negative_rotation_orders=false)</td></tr>
<tr class="memdesc:a5bedc958816f76f8453f8841c820aaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the complex argument of a raw feature at a number of image locations.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a5bedc958816f76f8453f8841c820aaac">More...</a><br /></td></tr>
<tr class="separator:a5bedc958816f76f8453f8841c820aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfcb13e25a3aa0514abd7c51013de20"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a0cfcb13e25a3aa0514abd7c51013de20">getSpatialBasisCopy</a> (const int basis_index) const</td></tr>
<tr class="memdesc:a0cfcb13e25a3aa0514abd7c51013de20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of one of the spatial basis functions images.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a0cfcb13e25a3aa0514abd7c51013de20">More...</a><br /></td></tr>
<tr class="separator:a0cfcb13e25a3aa0514abd7c51013de20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd68f643fe0da3358e1fcba70a1c180"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a3fd68f643fe0da3358e1fcba70a1c180">getFrequencyBasisCopy</a> (const int basis_index) const</td></tr>
<tr class="memdesc:a3fd68f643fe0da3358e1fcba70a1c180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the frequency domain representation of one of the basis functions.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a3fd68f643fe0da3358e1fcba70a1c180">More...</a><br /></td></tr>
<tr class="separator:a3fd68f643fe0da3358e1fcba70a1c180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c30992e31d54d1c7f3fa7d99f01a7a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a9c30992e31d54d1c7f3fa7d99f01a7a1">getNumBases</a> () const</td></tr>
<tr class="memdesc:a9c30992e31d54d1c7f3fa7d99f01a7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of basis functions used by the object.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a9c30992e31d54d1c7f3fa7d99f01a7a1">More...</a><br /></td></tr>
<tr class="separator:a9c30992e31d54d1c7f3fa7d99f01a7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f11115cc7aaf70fbff288aba69a3695"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a1f11115cc7aaf70fbff288aba69a3695">getBasisInfo</a> (const int basis_index, int &amp;j, int &amp;k) const</td></tr>
<tr class="memdesc:a1f11115cc7aaf70fbff288aba69a3695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the j and k parameters for a given basis in the list.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a1f11115cc7aaf70fbff288aba69a3695">More...</a><br /></td></tr>
<tr class="separator:a1f11115cc7aaf70fbff288aba69a3695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeda83c19f2f82a5b24c2f8915da9bc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#adeda83c19f2f82a5b24c2f8915da9bc8">setScalarInputImage</a> (const cv::Mat &amp;in)</td></tr>
<tr class="memdesc:adeda83c19f2f82a5b24c2f8915da9bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to put a new scalar input image into the object.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#adeda83c19f2f82a5b24c2f8915da9bc8">More...</a><br /></td></tr>
<tr class="separator:adeda83c19f2f82a5b24c2f8915da9bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a7d300301b851f7eb6cc1bb257ca46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a70a7d300301b851f7eb6cc1bb257ca46">setVectorInputImage</a> (const cv::Mat &amp;in_magnitude, const cv::Mat &amp;in_orientation)</td></tr>
<tr class="memdesc:a70a7d300301b851f7eb6cc1bb257ca46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to put a new scalar input image into the object.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a70a7d300301b851f7eb6cc1bb257ca46">More...</a><br /></td></tr>
<tr class="separator:a70a7d300301b851f7eb6cc1bb257ca46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7a63775ab8ed76349fc6487f61294b"><td class="memItemLeft" align="right" valign="top">std::complex&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a7b7a63775ab8ed76349fc6487f61294b">singleWindowFeature</a> (const int raw_feature_num, const cv::Point p)</td></tr>
<tr class="memdesc:a7b7a63775ab8ed76349fc6487f61294b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of a raw feature at a single image location.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a7b7a63775ab8ed76349fc6487f61294b">More...</a><br /></td></tr>
<tr class="separator:a7b7a63775ab8ed76349fc6487f61294b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe29d3b3a084d4a0f1abcfc01a6d722f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#abe29d3b3a084d4a0f1abcfc01a6d722f">stringToCalcMethod</a> (const std::string &amp;method_string, <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfb">calculationMethod_enum</a> &amp;method_enum)</td></tr>
<tr class="memdesc:abe29d3b3a084d4a0f1abcfc01a6d722f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a human readable string to the enumeration representing the calculation method.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#abe29d3b3a084d4a0f1abcfc01a6d722f">More...</a><br /></td></tr>
<tr class="separator:abe29d3b3a084d4a0f1abcfc01a6d722f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6310275d1edf0327f5ec524d61a5b31a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a6310275d1edf0327f5ec524d61a5b31a">stringToCoupleMethod</a> (const std::string &amp;method_string, <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24">couplingMethod_enum</a> &amp;method_enum)</td></tr>
<tr class="memdesc:a6310275d1edf0327f5ec524d61a5b31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a human readable string to the enumeration representing the coupling method.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a6310275d1edf0327f5ec524d61a5b31a">More...</a><br /></td></tr>
<tr class="separator:a6310275d1edf0327f5ec524d61a5b31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2098e28c81c708164d2d10b0ac0a1385"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2098e28c81c708164d2d10b0ac0a1385">stringBasisType</a> (const std::string &amp;basis_type_string, <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4e">basisType_enum</a> &amp;basis_type_enum)</td></tr>
<tr class="memdesc:a2098e28c81c708164d2d10b0ac0a1385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a human readable string to the enumeration representing the basis type.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a2098e28c81c708164d2d10b0ac0a1385">More...</a><br /></td></tr>
<tr class="separator:a2098e28c81c708164d2d10b0ac0a1385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c77fd5a4d2f307ef610fec193caa4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a1d1c77fd5a4d2f307ef610fec193caa4">stringToFeatureSet</a> (const std::string &amp;feature_set_string, <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3">featureSet_enum</a> &amp;feature_set_enum)</td></tr>
<tr class="memdesc:a1d1c77fd5a4d2f307ef610fec193caa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a human readable string to the enumeration representing the feature set type.  <a href="class_r_i_features_1_1_r_i_feat_extractor.html#a1d1c77fd5a4d2f307ef610fec193caa4">More...</a><br /></td></tr>
<tr class="separator:a1d1c77fd5a4d2f307ef610fec193caa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the main class that encapsulates the rotation invariant feature extraction process. </p>
<p>Once set up, images may be 'placed into' the extractor and then queried to get various features. More details will be found in my forthcoming DPhil thesis. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac511557a4d31dffbeaa0845e12779a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac511557a4d31dffbeaa0845e12779a4e">&#9670;&nbsp;</a></span>basisType_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4e">RIFeatures::RIFeatExtractor::basisType_enum</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration representing the type of basis functions used by the extracor </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac511557a4d31dffbeaa0845e12779a4ea946178e16dfeaca2689a02d75c844ef3"></a>btSoftHist&#160;</td><td class="fielddoc"><p>Basis functions with a soft histogram radial profile. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac511557a4d31dffbeaa0845e12779a4ea00eae59978045e7d041b8bf1606983b1"></a>btZernike&#160;</td><td class="fielddoc"><p>Basis functions with based on Zernike moments (NB this has not been well maintained and may be incompatible with certain other features) </p>
</td></tr>
</table>

</div>
</div>
<a id="af16b938a9a35a24e4115f78231739bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16b938a9a35a24e4115f78231739bfb">&#9670;&nbsp;</a></span>calculationMethod_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfb">RIFeatures::RIFeatExtractor::calculationMethod_enum</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration representing the methods that the class can use to perform the calculations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af16b938a9a35a24e4115f78231739bfbace69d10f09c2f9463511587bc94c0f2b"></a>cmSpatial&#160;</td><td class="fielddoc"><p>Use spatial domain calculations (convolutions) </p>
</td></tr>
<tr><td class="fieldname"><a id="af16b938a9a35a24e4115f78231739bfba5ac7bf4028b3ff633acbc15b1415edfb"></a>cmFrequency&#160;</td><td class="fielddoc"><p>Use frequency-domain calculations via the fast Fourier transform. </p>
</td></tr>
<tr><td class="fieldname"><a id="af16b938a9a35a24e4115f78231739bfba8393f88bba58fc1d31613f9cffcb328e"></a>cmAuto&#160;</td><td class="fielddoc"><p>Automatically determine the best method to use based on the number of image locations queried (not guaranteed to be fastest!) </p>
</td></tr>
</table>

</div>
</div>
<a id="a2714f17c5759c1d0d4dfde647df6ed24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2714f17c5759c1d0d4dfde647df6ed24">&#9670;&nbsp;</a></span>couplingMethod_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24">RIFeatures::RIFeatExtractor::couplingMethod_enum</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration representing the methods the class can use to perform coupling calculations between pairs of raw features </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2714f17c5759c1d0d4dfde647df6ed24a941ba36a5a1424f0de64e1e2f8474d8e"></a>comElementwise&#160;</td><td class="fielddoc"><p>Perform the coupling coupling on each pixel at a time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2714f17c5759c1d0d4dfde647df6ed24aa4f291c1aba930a2ea44cf2b1a89e0cd"></a>comVectorised&#160;</td><td class="fielddoc"><p>Perform coupling on entire images at a time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2714f17c5759c1d0d4dfde647df6ed24a1b65c5fa21c706bb0f1865c6c3fddddc"></a>comAuto&#160;</td><td class="fielddoc"><p>Automatically determine which method to use based on the number of locations queried (not guaranteed to be fastest!) </p>
</td></tr>
</table>

</div>
</div>
<a id="a997eda5e295d0281a0adf20b44008cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997eda5e295d0281a0adf20b44008cc3">&#9670;&nbsp;</a></span>featureSet_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3">RIFeatures::RIFeatExtractor::featureSet_enum</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration representing the feature set used by the extractor </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a997eda5e295d0281a0adf20b44008cc3a90c0d4204fea5bf9339472063e0abf65"></a>fsBasic&#160;</td><td class="fielddoc"><p>Basic feature set, with no feature coupling. </p>
</td></tr>
<tr><td class="fieldname"><a id="a997eda5e295d0281a0adf20b44008cc3a325b9896dd17d1b8098ece318a592b17"></a>fsSimpleCouple&#160;</td><td class="fielddoc"><p>Feature set with coupling between features of the same rotation order. </p>
</td></tr>
<tr><td class="fieldname"><a id="a997eda5e295d0281a0adf20b44008cc3acebbb945eb19cd07c06e6fd61976a02e"></a>fsExtraCouple&#160;</td><td class="fielddoc"><p>Feature set with coupling between all possible pairs of features. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6bf542a8274d1da1346bcad7878feebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf542a8274d1da1346bcad7878feebf">&#9670;&nbsp;</a></span>RIFeatExtractor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RIFeatures::RIFeatExtractor::RIFeatExtractor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Note that an object constructed this way will have no functionality until initialised </p>

</div>
</div>
<a id="ab857069a31f922ec45adf94fe80d0952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab857069a31f922ec45adf94fe80d0952">&#9670;&nbsp;</a></span>RIFeatExtractor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RIFeatures::RIFeatExtractor::RIFeatExtractor </td>
          <td>(</td>
          <td class="paramtype">const cv::Size&#160;</td>
          <td class="paramname"><em>image_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>basis_diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_rot_orders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_fourier_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfb">calculationMethod_enum</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfba8393f88bba58fc1d31613f9cffcb328e">cmAuto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_spatial_memoisation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24">couplingMethod_enum</a>&#160;</td>
          <td class="paramname"><em>couple_method</em> = <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24a1b65c5fa21c706bb0f1865c6c3fddddc">comAuto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3">featureSet_enum</a>&#160;</td>
          <td class="paramname"><em>feature_set</em> = <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3a90c0d4204fea5bf9339472063e0abf65">fsBasic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_derived_rotation_order</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4e">basisType_enum</a>&#160;</td>
          <td class="paramname"><em>basis_form</em> = <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4ea946178e16dfeaca2689a02d75c844ef3">btSoftHist</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with initialisation. </p>
<p>Constructs a fully functional object. Defines various parameters of the object. This may be slow due to the need to precalculate the basis functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_size</td><td>Size that the input images will be </td></tr>
    <tr><td class="paramname">basis_diameter</td><td>Diameter (in pixels) of the circular detection window </td></tr>
    <tr><td class="paramname">num_radii</td><td>Number of radial profiles in the set of basis functions (parameter J). Note that negative values are not permitted and will be silently treated as 0. </td></tr>
    <tr><td class="paramname">num_rot_orders</td><td>Maximum rotation order in the set of basis functions (parameter K). Note that currently values above 6 are not implemented and will be treated as 6. </td></tr>
    <tr><td class="paramname">num_fourier_coefs</td><td>Number of Fourier coefficients in the orientation histogram expansion (parameter M). Note that negative values are not permitted and will be silently treated as 0. </td></tr>
    <tr><td class="paramname">method</td><td>Calculation method the object will use to calulate the raw features </td></tr>
    <tr><td class="paramname">use_spatial_memoisation</td><td>If true, use a memoiser to store values calculated using the spatial method. This will have no effect if method is set to <code>cmFrequency</code>. </td></tr>
    <tr><td class="paramname">couple_method</td><td>Method to use for coupling calculations between raw features </td></tr>
    <tr><td class="paramname">feature_set</td><td>Type of derived features that can be extracted. Governs what type of coupling is available </td></tr>
    <tr><td class="paramname">max_derived_rotation_order</td><td>Maximum rotation order of derived features </td></tr>
    <tr><td class="paramname">basis_form</td><td>The form of the basis functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aae8882738b4bd24f20fc46a0377dbf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8882738b4bd24f20fc46a0377dbf03">&#9670;&nbsp;</a></span>createRawFeats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::createRawFeats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate all raw features. </p>
<p>Calculates all raw features and stores them internally ready for further queries. Note that it is not necessary to call this function in order to use other methods that make use of the raw features. However, if you know that you need every raw feature at a large number of image locations, this is the simplest, and probably the most efficient, way to do it. </p>

</div>
</div>
<a id="a1f11115cc7aaf70fbff288aba69a3695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f11115cc7aaf70fbff288aba69a3695">&#9670;&nbsp;</a></span>getBasisInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RIFeatures::RIFeatExtractor::getBasisInfo </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>basis_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the j and k parameters for a given basis in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_index</td><td>Index of the basis functionin question. Should be between 0 (inclusive) and <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a9c30992e31d54d1c7f3fa7d99f01a7a1" title="Get the number of basis functions used by the object.">getNumBases()</a></code> (exclusive). </td></tr>
    <tr><td class="paramname">j</td><td>The j value (radial profile index) of this basis function returned by reference. </td></tr>
    <tr><td class="paramname">k</td><td>The k value (rotation order) of this basis function returned by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e1bc4d502b65c7bab5dcc7855d9c14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1bc4d502b65c7bab5dcc7855d9c14e">&#9670;&nbsp;</a></span>getDerivedFeature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::getDerivedFeature </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>first_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputIterator&#160;</td>
          <td class="paramname"><em>last_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>derived_feat_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a single derived feature from a number of image locations. </p>
<p>Takes a sequence of image locations (each described by a cv::Point) and calculates the specified derived feature at these image locations in the input image. The input image must have been set up prior to calling this method. The resulting feature values are placed into the corresponding elements of the output sequence.</p>
<p>You must also ensure that all the points are valid, i.e. at least the 'halfsize' of the relevant basis function away from the image edge (see <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af0775c8aac6d11548e481802a8b96617" title="Get the &#39;halfsize&#39; of the largest spatial basis function.">getMaxSpatBasisHalfsize()</a></code>).</p>
<p>This method is thread-safe in that it can be used in OpenMP parallel sections where other threads are calling this method other thread-safe methods without causing data races. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInputIterator</td><td>The type of the iterator to the start of the input sequence of image locations. This must dereference to a cv::Point and be at least an input iterator (according to C++ standard library definitions). </td></tr>
    <tr><td class="paramname">TOutputIterator</td><td>The type of the iterator the output feature values. Must be at least an output iterator (according to C++ standard library definitions) and support assignment to a float value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_point</td><td>Iterator to the first image location, i.e. the centre of the first detection window. </td></tr>
    <tr><td class="paramname">last_point</td><td>Iterator to the end of the image location lists </td></tr>
    <tr><td class="paramname">derived_feat_num</td><td>The number of the derived feature to calculate (must be between 0 (inclusive) and <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a085f643773aed8db95a84e64b906139b" title="Get the number of derived features available in the current feature set.">getNumDerivedFeats()</a> (exclusive)) </td></tr>
    <tr><td class="paramname">dest</td><td>Output iterator to the start of the output sequence where the derived feature scores will be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59868a6f9574817edbfc9f9c7a62fdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59868a6f9574817edbfc9f9c7a62fdd7">&#9670;&nbsp;</a></span>getDerivedFeatureVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::getDerivedFeatureVector </td>
          <td>(</td>
          <td class="paramtype">const cv::Point&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a full feature vector for a single image location. </p>
<p>Takes a single image location and calculates the full feature vector of derived features at this image location in the input image. The input image must have been set up prior to calling this method. The resulting feature values are placed into the output container, which must be pre-allocated to the correct size (given by the <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a085f643773aed8db95a84e64b906139b" title="Get the number of derived features available in the current feature set.">getNumDerivedFeats()</a></code> method).</p>
<p>You must also ensure that all the points are valid, i.e. at least the 'halfsize' of the relevant basis function away from the image edge (see <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af0775c8aac6d11548e481802a8b96617" title="Get the &#39;halfsize&#39; of the largest spatial basis function.">getMaxSpatBasisHalfsize()</a></code>).</p>
<p>This method is thread-safe in that it can be used in OpenMP parallel sections where other threads are calling this method or other thread-safe methods without causing data races.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOutputIterator</td><td>The type of the iterator the output feature values. Must be at least an output iterator (according to C++ standard library definitions) and support assignment to a float value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Image location, i.e. the centre of the detection window. </td></tr>
    <tr><td class="paramname">dest</td><td>Output iterator to the start of the output container where the derived feature scores will be placed. The container must have been pre-allocated to the correct size before calling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33e8a11672f8ff87a6224bfd44fb6d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e8a11672f8ff87a6224bfd44fb6d39">&#9670;&nbsp;</a></span>getFeatsUsingLowJ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::getFeatsUsingLowJ </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Jmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_feature_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of the derived features that use only small basis functions. </p>
<p>Finds a list of the derived features that can be calculated using only small basis functions (i.e. those with a small <img class="formulaInl" alt="$ j &lt; j_{max}$" src="form_1.png"/>). This can be useful for training models that should use a smaller spatial support than the full detection radius. A vector of the indices of the derived features is returned by reference. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Jmax</td><td>Index of the maximum radial profile to to be included in the list. Should be between 0 (inclusive) and the num_radii value that the object was constructed with (exclusive). </td></tr>
    <tr><td class="paramname">output_feature_list</td><td>This is returned by reference and contains the list of derived feature indices that satisfy the condition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5138b75562d7d33bef2f50a2d4d3b5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5138b75562d7d33bef2f50a2d4d3b5d8">&#9670;&nbsp;</a></span>getFeatsWithGivenR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::getFeatsWithGivenR </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>raw_feat_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>include_negatives</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Jmax</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of raw feature indices with a given effective rotation order. </p>
<p>For a given effective rotation order (r) get a list of indices of the raw features that have this effective rotation order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The effective rotation order. </td></tr>
    <tr><td class="paramname">raw_feat_ind</td><td>This vector is returned by reference containing the list of raw feature indices that have effective rotation order r. </td></tr>
    <tr><td class="paramname">include_negatives</td><td>If true, features with a rotation order of -r are also included in the list. </td></tr>
    <tr><td class="paramname">Jmax</td><td>Only include raw features with that use a small basis function with <img class="formulaInl" alt="$ (j &lt; j_{max}$" src="form_0.png"/>). Should be between 0 (inclusive) and the num_radii value that the object was constructed with (exclusive). If negative or omitted, raw features using all radial profiles are inlcuded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fd68f643fe0da3358e1fcba70a1c180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd68f643fe0da3358e1fcba70a1c180">&#9670;&nbsp;</a></span>getFrequencyBasisCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat RIFeatures::RIFeatExtractor::getFrequencyBasisCopy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>basis_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a copy of the frequency domain representation of one of the basis functions. </p>
<p>Do not call this if the object was initialised with the <code>cmSpatial</code> calculation method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_index</td><td>Index of the basis function in question. Should be between 0 (inclusive) and <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a9c30992e31d54d1c7f3fa7d99f01a7a1" title="Get the number of basis functions used by the object.">getNumBases()</a></code> (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A deep copy (clone) of the frequency domain representation of the requested basis function. </dd></dl>

</div>
</div>
<a id="af0775c8aac6d11548e481802a8b96617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0775c8aac6d11548e481802a8b96617">&#9670;&nbsp;</a></span>getMaxSpatBasisHalfsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RIFeatures::RIFeatExtractor::getMaxSpatBasisHalfsize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Jmax</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the 'halfsize' of the largest spatial basis function. </p>
<p>The size of the spatial basis functions are always odd, and the 'halfsize' is value such that the side length of the square basis function image is 2*halfsize + 1. This is important because you must ensure that whenever you ask for a feature an image location, that location must be at least 'halfsize' pixels from the edge of the image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Jmax</td><td>If this value is non-negative, only the basis functions with <img class="formulaInl" alt="$j &lt;= J_{max}$" src="form_2.png"/> are considered. If only features using these basis functions are used, the image locations may be closer to the edge of the image than the halfsize of the biggest basis in the set. If Jmax is negative or not provided, all basis functions are considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The halfsize of the largest basis function in the set. </dd></dl>

</div>
</div>
<a id="a9c30992e31d54d1c7f3fa7d99f01a7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c30992e31d54d1c7f3fa7d99f01a7a1">&#9670;&nbsp;</a></span>getNumBases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RIFeatures::RIFeatExtractor::getNumBases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of basis functions used by the object. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of basis functions used. </dd></dl>

</div>
</div>
<a id="a085f643773aed8db95a84e64b906139b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085f643773aed8db95a84e64b906139b">&#9670;&nbsp;</a></span>getNumDerivedFeats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RIFeatures::RIFeatExtractor::getNumDerivedFeats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of derived features available in the current feature set. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of derived features </dd></dl>

</div>
</div>
<a id="a9337a05a8d826fff396d2eb88ca8b64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9337a05a8d826fff396d2eb88ca8b64d">&#9670;&nbsp;</a></span>getNumRawFeats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RIFeatures::RIFeatExtractor::getNumRawFeats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of raw features available in the current feature set. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of raw features </dd></dl>

</div>
</div>
<a id="a5bedc958816f76f8453f8841c820aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bedc958816f76f8453f8841c820aaac">&#9670;&nbsp;</a></span>getRawFeatureArg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::getRawFeatureArg </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>first_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputIterator&#160;</td>
          <td class="paramname"><em>last_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>raw_feature_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>cos_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>sin_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flip_negative_rotation_orders</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the complex argument of a raw feature at a number of image locations. </p>
<p>Takes a sequence of image locations (each described by a cv::Point) and calculates the complex argument of the raw features at these image locations in the input image. The input image must have been set up prior to calling this method. The sine and cosine value of the resulting feature values are placed into the corresponding elements of the output sequences.</p>
<p>You must also ensure that all the points are valid, i.e. at least the 'halfsize' of the relevant basis function away from the image edge (see <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af0775c8aac6d11548e481802a8b96617" title="Get the &#39;halfsize&#39; of the largest spatial basis function.">getMaxSpatBasisHalfsize()</a></code>). Note that these features are <b>not</b> rotation invariant.</p>
<p>This method is thread-safe in that it can be used in OpenMP parallel sections where other threads are calling this method or other thread-safe methods without causing data races. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInputIterator</td><td>The type of the iterator to the start of the input sequence of image locations. This must dereference to a cv::Point and be at least an input iterator (according to C++ standard library definitions). </td></tr>
    <tr><td class="paramname">TOutputIterator</td><td>The type of the iterator the output feature values. Must be at least an output iterator (according to C++ standard library definitions) and support assignment to a float value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_point</td><td>Iterator to the first image location, i.e. the centre of the first detection window. </td></tr>
    <tr><td class="paramname">last_point</td><td>Iterator to the end of the image location lists </td></tr>
    <tr><td class="paramname">raw_feature_index</td><td>The number of the raw feature whose argument should be calculated (must be between 0 (inclusive) and <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a9337a05a8d826fff396d2eb88ca8b64d" title="Get the number of raw features available in the current feature set.">getNumRawFeats()</a> (exclusive)) </td></tr>
    <tr><td class="paramname">cos_dest</td><td>Output iterator to the start of the output sequence where the cosine of the raw feature argument will be placed. </td></tr>
    <tr><td class="paramname">sin_dest</td><td>Output iterator to the start of the output sequence where the sine of raw feature argument will be placed. </td></tr>
    <tr><td class="paramname">flip_negative_rotation_orders</td><td>If the raw feature has a negative effective rotation order, flip the output argument to create a feature with a positive effective rotation order. In effect this changes the sign on the sine output part. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0160c2ddac865364422c67bc3c6a671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0160c2ddac865364422c67bc3c6a671b">&#9670;&nbsp;</a></span>getRawFeatureVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::getRawFeatureVector </td>
          <td>(</td>
          <td class="paramtype">const cv::Point&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a full raw feature vector for a single image location. </p>
<p>Takes a single image location and calculates the full feature vector of raw features at this image location in the input image. The input image must have been set up prior to calling this method. The resulting feature values are placed into the output container, which must be pre-allocated to the correct size (given by the <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a9337a05a8d826fff396d2eb88ca8b64d" title="Get the number of raw features available in the current feature set.">getNumRawFeats()</a></code> method).</p>
<p>You must also ensure that all the points are valid, i.e. at least the 'halfsize' of the relevant basis function away from the image edge (see <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af0775c8aac6d11548e481802a8b96617" title="Get the &#39;halfsize&#39; of the largest spatial basis function.">getMaxSpatBasisHalfsize()</a></code>).</p>
<p>This method is thread-safe in that it can be used in OpenMP parallel sections where other threads are calling this method or other thread-safe methods without causing data races.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOutputIterator</td><td>The type of the iterator the output feature values. Must be at least an output iterator (according to C++ standard library definitions) that derefences to a std::complex&lt;float&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Image location, i.e. the centre of the detection window. </td></tr>
    <tr><td class="paramname">dest</td><td>Output iterator to the start of the output container where the derived feature scores will be placed. The container must have been pre-allocated to the correct size before calling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cfcb13e25a3aa0514abd7c51013de20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfcb13e25a3aa0514abd7c51013de20">&#9670;&nbsp;</a></span>getSpatialBasisCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat RIFeatures::RIFeatExtractor::getSpatialBasisCopy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>basis_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a copy of one of the spatial basis functions images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_index</td><td>Index of the basis function in question. Should be between 0 (inclusive) and <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a9c30992e31d54d1c7f3fa7d99f01a7a1" title="Get the number of basis functions used by the object.">getNumBases()</a></code> (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A deep copy (clone) of the requested basis function. </dd></dl>

</div>
</div>
<a id="ad23bed3ee42d517e33bba3d12db68b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23bed3ee42d517e33bba3d12db68b79">&#9670;&nbsp;</a></span>initialise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::initialise </td>
          <td>(</td>
          <td class="paramtype">const cv::Size&#160;</td>
          <td class="paramname"><em>image_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>basis_diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_rot_orders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_fourier_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfb">calculationMethod_enum</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfba8393f88bba58fc1d31613f9cffcb328e">cmAuto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_spatial_memoisation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24">couplingMethod_enum</a>&#160;</td>
          <td class="paramname"><em>couple_method</em> = <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24a1b65c5fa21c706bb0f1865c6c3fddddc">comAuto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3">featureSet_enum</a>&#160;</td>
          <td class="paramname"><em>feature_set</em> = <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3a90c0d4204fea5bf9339472063e0abf65">fsBasic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_derived_rotation_order</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4e">basisType_enum</a>&#160;</td>
          <td class="paramname"><em>basis_form</em> = <code><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4ea946178e16dfeaca2689a02d75c844ef3">btSoftHist</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises or re-initialises an object. </p>
<p>Defines various parameters of the object. This may be slow due to the need to precalculate the basis functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_size</td><td>Size that the input images will be </td></tr>
    <tr><td class="paramname">basis_diameter</td><td>Diameter (in pixels) of the circular detection window </td></tr>
    <tr><td class="paramname">num_radii</td><td>Number of radial profiles in the set of basis functions (parameter J). Note that negative values are not permitted and will be silently treated as 0. </td></tr>
    <tr><td class="paramname">num_rot_orders</td><td>Maximum rotation order in the set of basis functions (parameter K). Note that currently values above 6 are not implemented and will be treated as 6. </td></tr>
    <tr><td class="paramname">num_fourier_coefs</td><td>Number of Fourier coefficients in the orientation histogram expansion (parameter M). Note that negative values are not permitted and will be silently treated as 0. </td></tr>
    <tr><td class="paramname">method</td><td>Calculation method the object will use to calulate the raw features </td></tr>
    <tr><td class="paramname">use_spatial_memoisation</td><td>If true, use a memoiser to store values calculated using the spatial method. This will have no effect if method is set to <code>cmFrequency</code>. </td></tr>
    <tr><td class="paramname">couple_method</td><td>Method to use for coupling calculations between raw features </td></tr>
    <tr><td class="paramname">feature_set</td><td>Type of derived features that can be extracted. Governs what type of coupling is available </td></tr>
    <tr><td class="paramname">max_derived_rotation_order</td><td>Maximum rotation order of derived features </td></tr>
    <tr><td class="paramname">basis_form</td><td>The form of the basis functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adeda83c19f2f82a5b24c2f8915da9bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeda83c19f2f82a5b24c2f8915da9bc8">&#9670;&nbsp;</a></span>setScalarInputImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::setScalarInputImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function to put a new scalar input image into the object. </p>
<p>Invalidates any data held on the previous image and performs preparatory operations on the new image. Use this function to put a scalar (single channel) image (such as a plain monochrome intensity image) into the extractor. Only call this if the object was initialised with num_fourier_coefs (m) = 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>New input image. The object will take a local deep copy of this image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70a7d300301b851f7eb6cc1bb257ca46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a7d300301b851f7eb6cc1bb257ca46">&#9670;&nbsp;</a></span>setVectorInputImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RIFeatures::RIFeatExtractor::setVectorInputImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>in_magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>in_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function to put a new scalar input image into the object. </p>
<p>Invalidates any data held on the previous image and performs preparatory operations on the new image. Use this function to put a vector (two channel) image (such as a gradient or motion field image) into the extractor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_magnitude</td><td>Magnitude of the new input image. The object will take a local deep copy of this image. </td></tr>
    <tr><td class="paramname">in_orientation</td><td>Orientationof the new input image. This must be defined in the standard mathematical sense, i.e. measured anti-clockwise from the positive x-axis (pointing right). The object will take a local deep copy of this image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b7a63775ab8ed76349fc6487f61294b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7a63775ab8ed76349fc6487f61294b">&#9670;&nbsp;</a></span>singleWindowFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; float &gt; RIFeatures::RIFeatExtractor::singleWindowFeature </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>raw_feature_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Point&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value of a raw feature at a single image location. </p>
<p>This method always uses the spatial (convolution) calculation method regardless of how the object was initialised. Ensure that an image has been placed into the extractor before calling this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_feature_num</td><td>Index of the raw feature to calculate </td></tr>
    <tr><td class="paramname">p</td><td>Image location at which to calculate the feature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The raw feature value in complex form. </dd></dl>

</div>
</div>
<a id="a2098e28c81c708164d2d10b0ac0a1385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2098e28c81c708164d2d10b0ac0a1385">&#9670;&nbsp;</a></span>stringBasisType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RIFeatures::RIFeatExtractor::stringBasisType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>basis_type_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#ac511557a4d31dffbeaa0845e12779a4e">basisType_enum</a> &amp;&#160;</td>
          <td class="paramname"><em>basis_type_enum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a human readable string to the enumeration representing the basis type. </p>
<p>The list of accepted strings is: </p><ul>
<li><code>"softhist"</code>, <code>"s"</code>, or <code>"soft_histograms"</code> is converted to <code>btSoftHist</code>. </li>
<li><code>"zernike"</code>, or <code>"z"</code> is converted to <code>btZernike</code>. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_type_string</td><td>The string to convert into a basis type. </td></tr>
    <tr><td class="paramname">basis_type_enum</td><td>The basis type represented in enumeration form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if conversion was succesful, otherwise false. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="abe29d3b3a084d4a0f1abcfc01a6d722f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe29d3b3a084d4a0f1abcfc01a6d722f">&#9670;&nbsp;</a></span>stringToCalcMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RIFeatures::RIFeatExtractor::stringToCalcMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#af16b938a9a35a24e4115f78231739bfb">calculationMethod_enum</a> &amp;&#160;</td>
          <td class="paramname"><em>method_enum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a human readable string to the enumeration representing the calculation method. </p>
<p>The list of accepted strings is: </p><ul>
<li><code>"spatial"</code>, or <code>"s"</code> is converted to <code>cmSpatial</code> </li>
<li><code>"frequency"</code>, or <code>"f"</code> is converted to <code>cmFrequency</code> </li>
<li><code>"auto"</code>, or <code>"a"</code> is converted to <code>cmAuto</code> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method_string</td><td>The string to convert into a calculation method </td></tr>
    <tr><td class="paramname">method_enum</td><td>The calculation method represented in enumeration form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if conversion was succesful, otherwise false. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a6310275d1edf0327f5ec524d61a5b31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6310275d1edf0327f5ec524d61a5b31a">&#9670;&nbsp;</a></span>stringToCoupleMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RIFeatures::RIFeatExtractor::stringToCoupleMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a2714f17c5759c1d0d4dfde647df6ed24">couplingMethod_enum</a> &amp;&#160;</td>
          <td class="paramname"><em>method_enum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a human readable string to the enumeration representing the coupling method. </p>
<p>The list of accepted strings is: </p><ul>
<li><code>"element-wise"</code>, or <code>"e"</code> is converted to <code>comElementwise</code>. </li>
<li><code>"vectorised"</code>, or <code>"v"</code> is converted to <code>comVectorised</code>. </li>
<li><code>"auto"</code>, or <code>"a"</code> is converted to <code>comAuto</code>. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method_string</td><td>The string to convert into a coupling method. </td></tr>
    <tr><td class="paramname">method_enum</td><td>The coupling method represented in enumeration form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if conversion was succesful, otherwise false. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1d1c77fd5a4d2f307ef610fec193caa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1c77fd5a4d2f307ef610fec193caa4">&#9670;&nbsp;</a></span>stringToFeatureSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RIFeatures::RIFeatExtractor::stringToFeatureSet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>feature_set_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_i_features_1_1_r_i_feat_extractor.html#a997eda5e295d0281a0adf20b44008cc3">featureSet_enum</a> &amp;&#160;</td>
          <td class="paramname"><em>feature_set_enum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a human readable string to the enumeration representing the feature set type. </p>
<p>The list of accepted strings is: </p><ul>
<li><code>"basic"</code>, or <code>"b"</code> is converted to <code>fsBasic</code>. </li>
<li><code>"couple_simple"</code>, <code>"simple"</code>, or <code>"s"</code> is converted to <code>fsSimpleCouple</code>. </li>
<li><code>"couple_extra"</code>, <code>"extra"</code>, or <code>"e"</code> is converted to <code>fsExtraCouple</code>. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_set_string</td><td>The string to convert into a feature set type. </td></tr>
    <tr><td class="paramname">feature_set_enum</td><td>The feature set type represented in enumeration form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if conversion was succesful, otherwise false. </dd></dl>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/chris/Developer/RIFeatures/include/RIFeatures/<a class="el" href="_r_i_feat_extractor_8hpp_source.html">RIFeatExtractor.hpp</a></li>
<li>/home/chris/Developer/RIFeatures/include/RIFeatures/RIFeatExtractor.tpp</li>
<li>/home/chris/Developer/RIFeatures/src/RIFeatExtractor.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
